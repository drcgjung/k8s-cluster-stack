name: Infrastructure

# gather user input of terraform workspace, which is now mapped to azure resource group as {prefix}-{workspace}-rg
on:
  workflow_dispatch:
    inputs:
      clustername:
        description: 'Cluster name without pre- or suffix (eg. dev001)'
        required: true
        default: ''

env:
  prefix: cx

jobs:
  createK8sResources:
    # name of the job starts with a "run-level" subordinate to the workflow such that we can
    # depend on them in order to implement workflow dependencies
    name: create k8s resources
    runs-on: ubuntu-latest
    # rely on successful detection of the workspace, ignore if empty
    env:
      WORKSPACE: ${{github.event.inputs.clustername}}
    steps:

    # This is needed to access blob storage and other resources directly
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{secrets.AZURE_CREDENTIALS }}

    # This is needed to install terraform 
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        terraform_version: 1.0.7

    # get the latest sources
    - name: Checkout
      uses: actions/checkout@v2

    # Initialize terraform 
    - name: Terraform Init
      id: tf_init
      working-directory: ./terraform
      run: | 
          az config set extension.use_dynamic_install=yes_without_prompt
          az account subscription list # temp, remove
          terraform init -backend-config="access_key=${{secrets.TFSTATE_STORAGEACCOUNT_KEY}}" -input=false
      # Create Workspace
    - name: Terraform Workspace List
      id: tf_workspace_list
      working-directory: ./terraform
      run: |
        echo $(terraform workspace list)
        echo "::set-output name=WORKSPACE::$(terraform workspace list | grep "${{github.event.inputs.clustername}}")"
      
    # Create Workspace
    - name: Terraform Workspace Create
      id: tf_workspace_create
      if: ${{steps.tf_workspace_list.outputs.WORKSPACE == '' }}
      working-directory: ./terraform
      run: | 
          terraform workspace new ${{github.event.inputs.clustername}}
          
    # Switch Workspace 
    - name: Terraform Workspace Select
      id: tf_workspace_select
      if: ${{steps.tf_workspace_list.outputs.WORKSPACE != '' }}
      working-directory: ./terraform
      run: | 
          terraform workspace select ${{github.event.inputs.clustername}}

    - name: Check if cluster exists
      id: check_cluster
      run: |
        if (az aks list --query "[?name == '${{env.prefix}}-${{github.event.inputs.clustername}}-aks-services'].name" | grep ${{github.event.inputs.clustername}}) > /dev/null
        then
          echo '::set-output name=EXISTS::true'
        fi

    - name: Terraform Config
      id: tf_config
      if:  ${{steps.check_cluster.outputs.EXISTS == 'true' }}
      working-directory: ./terraform
      run: |
        mv provider.tf provider.tf_muted
        terraform show -json | grep -o -E '"kube_admin_config":\[(\{|\*\*\*)(("client_certificate"|"client_key"|"username"|"password"|"host"|"cluster_ca_certificate"):"[^"]+"\,?)+(\}|\*\*\*)\]' > kube_admin_config.json
        echo  "::set-output name=AKS_HOST::$(  cat kube_admin_config.json | grep -o -E '"host":"[^"]+"' | sed  -n 's/^"host":"\(.*\)"$/\1/p' )"
        echo  "::set-output name=AKS_USER::$(  cat kube_admin_config.json | grep -o -E '"username":"[^"]+"' | sed  -n 's/^"username":"\(.*\)"$/\1/p' )"
        echo  "::set-output name=AKS_PASSWORD::$( cat kube_admin_config.json | grep -o -E '"password":"[^"]+"' | sed  -n 's/^"password":"\(.*\)"$/\1/p')"
        echo  "::set-output name=AKS_CLIENT_KEY::$( cat kube_admin_config.json | grep -o -E '"client_key":"[^"]+"' | sed  -n 's/^"client_key":"\(.*\)"$/\1/p')"
        echo  "::set-output name=AKS_CLIENT_CERTIFICATE::$( cat kube_admin_config.json | grep -o -E '"client_certificate":"[^"]+"' | sed  -n 's/^"client_certificate":"\(.*\)"$/\1/p')"
        echo  "::set-output name=AKS_CLUSTER_CERTIFICATE::$( cat kube_admin_config.json | grep -o -E '"cluster_ca_certificate":"[^"]+"' | sed  -n 's/^"cluster_ca_certificate":"\(.*\)"$/\1/p')"
    # Move back the providers (kubernetes, helm) in order to generate a plan
    - name: Terraform Plan
      working-directory: ./terraform
      run: |
        test -f provider.tf_muted && mv provider.tf_muted provider.tf
        #export TF_LOG="DEBUG"
        terraform plan \
        -var "prefix=${{env.prefix}}" \
        -var "environment=${{github.event.inputs.clustername}}" \
        -var "azure_subscription_id=${{secrets.AZURE_SUBSCRIPTION_ID}}" \
        -var "azure_client_id=${{secrets.AZURE_AD_CLIENT_ID}}" \
        -var "azure_client_secret=${{secrets.AZURE_AD_CLIENT_SECRET}}" \
        -var "azure_tenant_id=${{secrets.AZURE_TENANT_ID}}" \
        -var "azure_storage_access_key=${{secrets.TFSTATE_STORAGEACCOUNT_KEY}}" \
        -var "catenax_admin=${{secrets.CATENAX_ADMIN_USER}}" \
        -var "catenax_admin_password=${{secrets.CATENAX_ADMIN_PASSWORD}}" \
        -var "aks_host=${{steps.tf_config.outputs.AKS_HOST}}" \
        -var "aks_user=${{steps.tf_config.outputs.AKS_USER}}" \
        -var "aks_password=${{steps.tf_config.outputs.AKS_PASSWORD}}" \
        -var "aks_client_key=${{steps.tf_config.outputs.AKS_CLIENT_KEY}}" \
        -var "aks_client_certificate=${{steps.tf_config.outputs.AKS_CLIENT_CERTIFICATE}}" \
        -var "aks_cluster_certificate=${{steps.tf_config.outputs.AKS_CLUSTER_CERTIFICATE}}" \
        -out .terraform/terraform.plan \
        -input=false 
    # For debugging purposes, we log the resulting plan
    - name: Store Terraform Plan
      working-directory: ./terraform
      run: |
        az storage blob upload \
        --name ${{github.event.inputs.clustername}}terraform${GITHUB_SHA}.plan \
        --container-name tfplan \
        --account-name ${{env.prefix}}devtfstate \
        --auth-mode login \
        --file .terraform/terraform.plan \
        --metadata TYPE=TERRAFORM_PLAN
    # The actual terraform apply
    - name: Terraform Auto-Apply
      working-directory: ./terraform
      env:
        TF_LOG: INFO
      run: |
        terraform apply -auto-approve -input=false .terraform/terraform.plan 

  registercluster:
    needs: createK8sResources
    name: Register cluster in central argocd
    runs-on: ubuntu-latest
    steps:

    # get the latest sources
    - name: Checkout
      uses: actions/checkout@v2
    #- name: "Login to Azure"
    #  uses: azure/login@v1
    #  with:
    #    creds: ${{ secrets.AZURE_CREDENTIALS }}
    - name: "Set kubecontext (destination)"
      uses: azure/aks-set-context@v1
      with:
        creds: '${{ secrets.AZURE_CREDENTIALS }}'
        resource-group: '${{env.prefix}}-${{github.event.inputs.workspace}}-rg'
        cluster-name: '${{env.prefix}}-${{github.event.inputs.workspace}}-aks-services'
    - name: "Create serviceaccount"
      working-directory: register
      run: |
        kubectl apply -f serviceaccount.yaml
        kubectl apply -f clusterrole.yaml
        kubectl apply -f clusterrolebinding.yaml
    - name: "Set variables"
      working-directory: register
      run: |
        export SECRETNAME=$(kubectl -n kube-system get serviceaccount argocd-manager -o jsonpath={'.secrets[0].name'})
        export CADATA=$(kubectl -n kube-system get secret $SECRETNAME -o "jsonpath={.data.ca\.crt}")
        export KEYDATA=$(kubectl -n kube-system get secret tunnelfront-tls -o "jsonpath={.data.client\.key}")
        export CERTDATA=$(kubectl -n kube-system get secret tunnelfront-tls -o "jsonpath={.data.client\.pem}")
        export CONTEXTNAME=$(kubectl config view -o 'jsonpath={.contexts[0].name}' | base64 -w0)
        export CLUSTERSERVER=$(kubectl config view -o 'jsonpath={.clusters[0].cluster.server}' | base64 -w0)
        export CLUSTERCONFIG=$(cat config.temp | envsubst | base64 -w0)
    - name: "Set kubecontext (central argocd)"
      uses: azure/aks-set-context@v1
      with:
        creds: '${{ secrets.AZURE_CREDENTIALS }}'
        resource-group: 'cxtsi-hotel-budapest-rg'
        cluster-name: 'cxtsi-hotel-budapest-aks-services'
    - name: "Create registration"
      working-directory: register
      run: |
        cat registration.temp | envsubst > registration.yaml
        kubectl apply -f registration.yaml

  vault-deploy:
    name: Deploy Vault
    needs: registercluster
    if: ${{github.event.inputs.clustername}} == "vault"
    runs-on: ubuntu-latest
    env:
      CONFIGTOML: ${{secrets.CONFIGTOML}}
    steps:

      - name: Checkout repository
        uses: actions/checkout@v1

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{secrets.AZURE_CREDENTIALS }}

      - name: Kubernetes Login (vault)
        uses: azure/aks-set-context@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          resource-group: ${{env.prefix}}-${{github.event.inputs.clustername}}-rg
          cluster-name: ${{env.prefix}}-${{github.event.inputs.clustername}}-aks-services
      
      - name: Prepare unseal
        working-directory: vault/unseal
        run: |
          cat configtoml.temp | envsubst >> configtoml.yaml
          kubectl apply -f configtoml.yaml

      - name: Kubernetes Login (central)
        uses: azure/aks-set-context@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          resource-group: cxtsi-hotel-budapest-rg
          cluster-name: cxtsi-hotel-budapest-aks-services
      
      - name: Deploy Vault
        working-directory: vault/chart
        run: |
          helm upgrade vault . \
          --namespace argocd \
          --install \
          --wait \
          --atomic \
          --set vault.seal.tenantid=${{secrets.AZURE_TENANT_ID}} \
          --set vault.seal.clientid=${{secrets.AZURE_AD_CLIENT_ID}} \
          --set vault.seal.clientsecret=${{secrets.AZURE_AD_CLIENT_SECRET}} \
          --set vault.seal.azurevaultname=${{secrets.AZUREVAULTNAME}} \
          --set vault.seal.azurevaultkeyname=${{secrets.AZUREVAULTKEYNAME}} \
          --set vault.seal.subscriptionid=${{secrets.AZURE_SUBSCRIPTION_ID}}
